var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Exported-Functions","page":"API Reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"POMDPSolveSolver()\nPOMDPSolveHelp()\nPOMDPs.solve(::POMDPSolveSolver, pomdp::POMDP)","category":"page"},{"location":"api/#POMDPSolve.POMDPSolveSolver-Tuple{}","page":"API Reference","title":"POMDPSolve.POMDPSolveSolver","text":"POMDPSolveSolver(; kwargs...)\n\nConstructs a POMDPSolveSolver object with the specified options. The options correspond to the command-line options for the pomdp-solve program, as described in the POMDP-Solve documentation.\n\nKeyword Arguments\n\nstdout::Union{Nothing, AbstractString}: Redirect program's stdout to a file of this name. (default: nothing)\nrand_seed::Union{Nothing, Tuple{Int, Int, Int}}: Set the random seed for program execution. (default: nothing)\nstat_summary::Bool: Whether to keep and print internal execution stats. (default: false)\nmemory_limit::Int: Set upper bound memory usage. (default: -1 which results in no limit)\ntime_limit::Int: Set upper bound on execution time. (default: -1 which results in no limit)\nterminal_values::Union{Nothing,AbstractString}: Sets the terminal value function (starting point). (default: nothing)\nhorizon::Int: Sets the number of iterations of value iteration. (default: -1 which results in no limit)\ndiscount::Float64: Set the discount fact to use in value iteration (overrides POMDP discount). (default: NaN which doesn't override) \nstop_criteria::Symbol: Sets the value iteration stopping criteria. (default: :default -> :weak)\nstop_delta::Float64: Sets the precision for the stopping criteria check. (default: NaN -> 1e-9)\nsave_all::Bool: Sets whether or not to save every iteration's solution. (default: false)\nvi_variation::Symbol: Sets the general category of value iteration to use. (default: :default -> :normal)\nstart_epsilon::Float64: Sets the starting precision for adjustable epsilon VI. (default: NaN)\nend_epsilon::Float64: Sets the ending precision for adjustable epsilon VI. (default: NaN)\nepsilon_adjust::Float64: Sets the precision increment for adjustable epsilon VI. (default: NaN)\nmax_soln_size::Float64: Sets the max size for the fixed solution size VI. (default: NaN)\nhistory_length::Int: Sets history window to use for adjustable epsilon VI. (default: -1 -> do not use)\nhistory_delta::Int: Sets solution size delta to use for adjustable epsilon VI. (default: -1 -> do not use)\ndom_check::Bool: Controls whether simple domination check is done or not. (default: true)\nprune_epsilon::Float64: Sets the precision level for the prune operations. (default: NaN -> 1e-9)\nepsilon::Float64: General solution precision level setting. (default: NaN -> 1e-9)\nlp_epsilon::Float64: Precision use in linear programs. (default: NaN -> 1e-9)\nproj_purge::Symbol: Type of pruning to use for pre-iteration solving. (default: :default -> :normal_prune)\nq_purge::Symbol: Type of pruning to use for a post-iteration solving. (default: :default -> :normal_prune)\nwitness_points::Bool: Whether to include 'witness points' in solving. (default: false)\nalg_rand::Int: How many points to use to seed value function creation. (default: -1 -> do not use)\nprune_rand::Int: How many points to use to seed pruning process. (default: -1 -> do not use)\nmethod::Symbol: Selects the main solution algorithm to use. (default: :default -> :incprune)\nenum_purge::Symbol: The pruning method to use when using the 'enum' algorithm. (default: :default -> :normal_prune)\ninc_prune::Symbol: The variation of the incremental pruning algorithm. (default: :default -> normal)\nfg_type::Symbol: Finite grid method means to generate belief points. (default: :default -> :initial)\nfg_points::Int: Maximal number of belief points to use in finite grid. (default: -1 -> 10000)\nfg_save::Bool: Whether to save the points used in finite grid. (default: false)\nmcgs_traj_length::Int: Trajectory length for Monte Carlo belief generation. (default: -1 -> 100)\nmcgs_num_traj::Int: Number of trajectories for Monte Carlo belief generation. (default: -1 -> 1000)\nmcgs_traj_iter_count::Int: Times to iterate on a trajectory for MCGS method. (default: -1 -> 100)\nmcgs_prune_freq::Int: How frequently to prune during MCGS method. (default: -1 -> 100)\nfg_purge::Symbol: Finite grid method means to prune value functions. (default: :default -> :normal_prune)\nverbose::Bool: Turns on extra debugging output for a module. (default: :default)\n\nMore detailed description of options\n\nThese are descriptions taken from the POMDP-Solve documentation.\n\nstdout::Union{Nothing, AbstractString}\n\nThe pomdp-solve program displays much status and progress information to stdout.  If you want to have this redirected to a file instead, provide the file name as this parameter.  Not specifying this option will simply make this information go to normal stdout.\n\nrand_seed::Union{Nothing, Tuple{Int,Int,Int}}\n\nFor any functionality that requires random numbers, we want to be able to reproduce a given run by executing with the same random number seed.  This parameter allows you to set the initial random seed by specifying a string consisting of three integers separated by a colon (e.g., \"34523:12987:50732\" ) Not setting this value will result in the random seed being pseudo-randomized based on the system clock. \n\nstat_summary::Bool\n\nThe pomdp-solve program is capable of keeping various statistical information as it solves the problem.  If you want to track these stats and print them, set this flag to true.\n\nmemory_limit::Int\n\nThis option has not been tested successfully using the jll package.\n\nThis parameter allows you to set an upper bound on the amount of memory that this program uses. If the memory threshold is met, the program execution is terminated.  Without specifying this parameter, there will be no upper bound imposed by the pomdp-solve program (though the OS will naturally have something to say about this). \n\ntime_limit::Int\n\nThis parameter allows you to set an upper bound on the amount of time that this program will run. When this amount of time has elapsed, the program execution is terminated.  Without specifying this parameter, there will be no upper bound imposed by the pomdp-solve program.\n\nterminal_values::Union{Nothing,AbstractString}\n\nValue iteration assumes that at the end of the lifetime of the decision maker that no more values will be accrued.  This corresponds to a terminal value function of all zeroes.  This is essentially the default starting point for the program.  However, with this parameter, you can set a different terminal value function, which serves as the seed or initial starting point for value iteration.  Effectively, this allows you to take the output of one value iteration run and send it as input to the next.  The file format for this input file is identical to the output file format of this program (the \".alpha\" file). \n\nhorizon::Int\n\nValue iteration is iterative and thus we may want to find 'finite horizon' solutions for various reasons.  To make pomdp-solve terminate after a fixed number of iterations (aka epochs) set this value to be some positive number.  By default, value iteration will run for as many iterations as it take to 'converge' on the infinite horizon solution. \n\ndiscount::Float64\n\nOverrides the POMDP discount factor.\n\nThis sets the discount factor to use during value iteration which dictates the relative usefulness of future rewards compared to immediate rewards.\n\nstop_criteria::Symbol\n\nAt the end of each epoch of value iteration, a check is done to see whether the solutions have 'converged' to the (near) optimal infinite horizon solution.  there are more than one way to determine this stopping condition.  The exact semantics of each are not described here at this time.\n\nOptions: :exact, :weak, :bellman\n\nstop_delta::Float64\n\nWhen checking the stopping criteria at the end of each value iteration epoch, some of the stopping condition types use a tolerance/precision in their calculations.  This parameter allows you to set that precision.\n\nsave_all::Bool\n\nNormally, only the final solution is saved to a file, but if you would like to write out the solution to every epoch of value iteration, then set this flag to true.  The epoch number will be appened to the filenames that are output.\n\nvi_variation::Symbol\n\nIndependent of particular algortihms for computing one iteration of value iteration are a number of variations of value iteration meant to help speed up convergence.  We do not yet attempt to give a full description of the semantics of each here.\n\nOptions: :normal, :zlz, :adjustable_epsilon, :fixed_soln_size\n\nstart_epsilon::Float64\n\nWhen solving using the 'adjustable_epsilon' method of value iteration, we need to specify both a staring and ending precision. This is the starting precision.\n\nend_epsilon::Float64\n\nWhen solving using the 'adjustable_epsilon' method of value iteration, we need to specify both a staring and ending precision. This is the ending precision.\n\nepsilon_adjust::Float64\n\nWhen solving using the 'adjustable_epsilon' method of value iteration, we need to specify a staring and ending precision as well as the increment to use for each adjustment. This is the precision increment.\n\nmax_soln_size::Float64\n\nWhen solving using the 'fixedsolnsize' method we need to define what the maximal size of a soltuion we will tolerate.  This sets that limit. \n\nhistory_length::Int\n\nWhen using the 'adjustable_epsilon' value iteration variant, we need to compare solution sizes from the the rpevious epochs to see whethere or not the solutions are staying relatively constant in size.  To do this, we need to define a past window length, as well as a tolerance on how much variation in solution size we want to care about.  This parameter defines the length of the epoch window history to use when determining whether it is time to adjust the precision of the value iteration solution.\n\nhistory_delta::Int\n\nWhen using the 'adjustable_epsilon' value iteration variant, we need to compare solution sizes from the the previous epochs to see whether or not the solutions are staying relatively constant in size.  To do this, we need to define a past window length, as well as a tolerance on how much variation in solution size we want to care about.  This parameter defines the tolerance on what we will consider all solutions to be of the same size.\n\ndom_check::Bool\n\ncheck that can be done to discover useless components of a value function.  This is often useful, but there are circumstances in which it is best to turn this off.\n\nprune_epsilon::Float64\n\nThere are a number of ways to prune sets of value function components.  Each uses a precision actor which is this parameter.\n\nepsilon::Float64\n\nThis is the main precision setting parameter which will effect the preciseness fo the solution procedures.\n\nlp_epsilon::Float64\n\nMany solution procedures employ linear programming in their algorithms.  For those that do, thisk is the precision level used inside the linear programming routines.\n\nproj_purge::Symbol\n\nThe first step for most algorithms is to compute the forward projection of the previous iteration solution components. Combinations of these will comprise the current solution.  Prior to emplying any algorithm to find which combinations are needed (the heart of the POMDP solution algorithms) we can employ a process of pruning the projected set, often reducing the complexity of the algorithms.  This parameter decides what type of pruning to use at this step.  Details on the semantics of each type of pruning are not yet given here.\n\nOptions: :none, :domonly, :normal_prune, :epsilon_prune\n\nq_purge::Symbol\n\nSome algorithms will separately solve the problem for individual actions, then merge these results together.  The individual action solutions are referred to as the \"Q-functions\".  After merging, some pruning process will likely take place, but we can also choose to do a pre-merge pruning of these sets which often simplifies the merging process.  This parameter defines the method to use for this pre-merge pruning. \n\nOptions: :none, :domonly, :normal_prune, :epsilon_prune\n\nwitness_points::Bool\n\nKeeping 'witness points' means to track individual points that have been found that gave rise to individual value function components. These can often be used to help speed up the solution process.\n\nalg_rand::Int\n\nOne can speed up the discovery of the initial shape of the value function by randomly generating points and finding the value function components needed for those points.  This technique is used if this parameter has a non-zero value.\n\nprune_rand::Int\n\nWhen pruning sets of value function components, we can use a random set of points to help speed up the pruning process.  This parameter, if specified and non-zero, will define the number of random points to use in this way.\n\nmethod::Symbol\n\nThe pomdp-solve program implements a number of differnt algorithms.  This selects the one that should be used. Details of each method not yet provided here.\n\nOptions: :enum, :twopass, :linsup, :witness, :incprune, :grid, :mcgs\n\nenum_purge::Symbol\n\nWhen using the enumeration method, there will be times where the set of value function components will need to be pruned or purged of useless components.  This define the pruning method to use for this algorithm. \n\nOptions: :none, :domonly, :normal_prune, :epsilon_prune\n\ninc_prune::Symbol\n\nThe incremental pruning algorithm has a number of variations. This parameter selects the variation.  We do not yet discuss here the nuances of these variations.\n\nOptions: :normal, :restricted_region, :generalized\n\nfg_type::Symbol\n\nThe finite grid method needs a set of belief points to compute over.  There are a number of ways to generate this grid, and this parameter selects the technique to use.  We do not yet here discuss the details of each of these.\n\nOptions: :simplex, :pairwise, :search, :initial\n\nfg_points::Int\n\nThe finite grid method needs a set of belief points to compute over.  There are a number of ways to generate this grid, and this parameter selects the maximum number of points that should be generated during this process. \n\nfg_save::Bool\n\nThe finite grid method needs a set of belief points to compute over.  This parameter will turn on and off the saving of these belief points to an external file. \n\nmcgs_traj_length::Int\n\nThe Monte-Carlo, Gauss-Seidel method using trajectories through the belief space to lay down a grid of points that we will compute the optimal value funciton for.  This parameter defines the lengths of the trajectories.\n\nmcgs_num_traj::Int\n\nThe Monte-Carlo, Gauss-Seidel method using trajectories through the belief space to lay down a grid of points that we will compute the optimal value funciton for.  This parameter defines the number of trajectories to use.\n\nmcgs_traj_iter_count::Int\n\nThe Monte-Carlo, Gauss-Seidel method using trajectories through the belief space to lay down a grid of points that we will compute the optimal value funciton for.  This parameter defines the number of value function update iterations to use on a given set of trajectories.\n\nmcgs_prune_freq::Int\n\nThe Monte-Carlo, Gauss-Seidel method using trajectories through the belief space to lay down a grid of points that we will compute the optimal value funciton for.  This parameter defines how frequently we should prune the set of newly created value function facets during the generation of the value function points.\n\nfg_purge::Symbol\n\nDefines the technique to use during pruning when the finite grid method is being used.\n\nOptions: :none, :domonly, :normal_prune, :epsilon_prune\n\nverbose::Bool\n\nEach main module of pomdp-solve can be separately controlled as far as extra debugging output is concerned. This option can be used more than once to turn on debugging in more than one module.\n\nThe :none options is a julia specific option that turns off all output using Suppressor.jl.\n\nOptions: :context, :lp, :global, :timing, :stats, :cmdline, :main, :alpha, :proj,          :crosssum, :agenda, :enum, :twopass, :linsup, :witness, :incprune, :lpinterface,          :vertexenum, :mdp, :pomdp, :param, :parsimonious, :region, :approx_mcgs,          :zlz_speedup, :finite_grid, :mcgs, :none\n\n\n\n\n\n","category":"method"},{"location":"api/#POMDPSolve.POMDPSolveHelp-Tuple{}","page":"API Reference","title":"POMDPSolve.POMDPSolveHelp","text":"POMDPSolveHelp()\n\nThis function runs the pomdpsolve command with the -h option, which displays help information for pomdpsolve. \n\n\n\n\n\n","category":"method"},{"location":"api/#POMDPs.solve-Tuple{POMDPSolveSolver, POMDP}","page":"API Reference","title":"POMDPs.solve","text":"POMDPs.solve(solver::POMDPSolveSolver, pomdp::POMDP)\n\nSolves the given pomdp using the pomdpsolve program andAlphaVectorPolicy. The solver  depends on translating the POMDP to the .pomdp file format. Please reference POMDPFiles.jl for any issues with the translation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"POMDPSolve.get_options_list(::Dict{AbstractString,Any})\nPOMDPSolve.invalid_option_error(::AbstractString,::Symbol, ::Vector)\nPOMDPSolve.list_options(::Vector)","category":"page"},{"location":"api/#POMDPSolve.get_options_list-Tuple{Dict{AbstractString, Any}}","page":"API Reference","title":"POMDPSolve.get_options_list","text":"get_options_list(options::Dict{AbstractString,Any})\n\nTakes a dictionary of options and returns a list of strings of the form \"-option value\".\n\n\n\n\n\n","category":"method"},{"location":"api/#POMDPSolve.invalid_option_error-Tuple{AbstractString, Symbol, Vector}","page":"API Reference","title":"POMDPSolve.invalid_option_error","text":"invalid_option_error(option::AbstractString, option_selected::Symbol, option_constant::Vector)\n\nFormats and throws an error for an invalid option.\n\n\n\n\n\n","category":"method"},{"location":"api/#POMDPSolve.list_options-Tuple{Vector}","page":"API Reference","title":"POMDPSolve.list_options","text":"list_options(option_constant::Vector)\n\nTakes the list of options and returns a string of them separated by new line characters.\n\n\n\n\n\n","category":"method"},{"location":"#POMPDPSolve.jl","page":"Home","title":"POMPDPSolve.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia wrapper for the POMDP-Solve program, orginally developed at Brown University that uses the POMDPs.jl interface. This package uses the POMDPSolve_jll package, which was build using modifications from the code available from Tony Cassandra's pomdp.org page. The modfications are available in the JuliaPOMDP fork of pomdp-solve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The pomdp-solve program solves partially observable Markov decision processes (POMDPs), taking a model specification and producing a value function and action policy.  It employs many different algorithms, some exact and some approximate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parameters and parameter options are documented in the POMDPSolveSolver docstring. If the information cannot be found there, please refer to the JuliaPOMDP fork of pomdp-solve or the original pomdp-solve documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can use the Julia package manager to install POMDPSolve.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"POMDPSolve\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using POMDPSolve\nusing POMDPModels # for TigerPOMDP\npomdp = TigerPOMDP()\nsolver = POMDPSolveSolver()\npolicy = solve(solver, pomdp) # returns an AlphaVectorPolicy","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
